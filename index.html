<!DOCTYPE html>
<html>
  <head>
    <title>Optics from the ground up</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Optics from the ground up

Nicolas Rinaudo • [`@NicolasRinaudo`](https://twitter.com/NicolasRinaudo) • [Besedo](http://besedo.com)

---

## Overview

This is meant for Scala developers of beginner to intermediate levels.

Basic understanding of Scala syntax is expected.

Knowledge of Algebraic Data Types is useful, although we'll start with a quick recap of these.

---

class: center, middle

# Algebraic Data Types

---

## Product types

Composed of values of multiple types:

```scala
case class Classifier(
  name      : String,
  classCount: Int
)
```

---

## Sum types

Values are one of a known list of possible types:

```scala
sealed trait Auth

object Auth {
  case class Token(token: String) extends Auth

  case class Login(
    user    : String,
    password: String
  ) extends Auth
}
```

---

## ADTs

Compositions of sum and product types:

```scala
final case class MlService(
  auth      : Auth,
  classifier: Classifier
)
```

---

class: center, middle

# Lenses

---

## Motivation

Given an `MlService`:

```scala
val service = MlService(
  Auth.Login("jsmith", "Tr0ub4dor&3"),
  Classifier("news20", 20)
)
```

We want to change the classifier name to `news_20`.

---

## Motivation ²

Easy in an imperative language:

```scala
service.classifier.name = "news_20"
```

--

In Scala, not so much:

```scala
service.copy(
  classifier = service.classifier.copy(
    name = "news_20"
  )
)
```

---

## Generic setter type


```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
}
```

The type of _set a classifier name_ would be `Setter[MlService, String]`.

--

Sometimes though, we don't want to _set_ but to _modify_.

---

## Set and modify

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def modify(f: A => A)(s: S): S
}
```

--

`modify` _could_ have a default implementation, if we had a `get`.

---

## Set and get

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

--

`Setter` doesn't seem like such a good name anymore though.

Our type allows us to _focus_ on a specific part of an ADT...

---

## Lens!

```scala
trait Lens[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

--

This looks painful to instantiate. Let's give ourselves helpers.

---

## Creation helper

```scala
object Lens {
  def apply[S, A](
    setter: (A, S) => S,
    getter: S      => A
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

--

Naming a few of these types will be helpful later:

```scala
type Set[S, A] = (A, S) => S
type Get[S, A] = S => A
```

---
## Creation helper ²

```scala
object Lens {
  def apply[S, A](
    setter: Set[S, A],
    getter: Get[S, A]
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```
--

Now that we have all this, we can try to actually use it.
---

## Using lenses

```scala
val classifierLens = Lens[MlService, Classifier](
  (a, s) => s.copy(classifier = a),
  s      => s.classifier
)

val nameLens = Lens[Classifier, String](
  (a, s) => s.copy(name = a),
  s      => s.name
)
```

???

We *could* create a `Lens[MlService, String]` directly, but it's a better approach to design the smallest possible pieces and see if we have ways of easily composing them into larger pieces.

--

Aside : these sure look like they could be automatically generated...

---

## Using lenses ²

```scala
classifierLens.modify(nameLens.set("news_20"))(service)
// res1: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))
```
--

This is better than what we started with, but not by much...

It often helps to turn such things into functions to identify more generic patterns.

---

## Tidying up

```scala
def setName(
    l1: Lens[MlService, Classifier],
    l2: Lens[Classifier, String]
  )
  (b: String)(s: MlService): MlService =
    l1.modify(l2.set(b))(s)
```

--

There is nothing in this implementation that relies on knowing the types `MlService`, `Classifier`, or `String`.

---

## Polymorphic `setName`

```scala
def setName[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  (b: B)(s: S): S =
    l1.modify(l2.set(b))(s)
```

--

This is starting to look familiar...

---

## Generic `setter`

```scala
def setter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Set[S, B] = (b, s) =>
    l1.modify(l2.set(b))(s)
```

--

That looks a lot like half a `Lens[S, B]`. Can we write the other half?

---

## Generic `getter`

```scala
def getter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Get[S, B] = s =>
    l2.get(l1.get(s))
```

--

We can compose lenses!

---
## Composing lenses

```scala
def composeLL[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  ) = Lens[S, B](setter(l1, l2), getter(l1, l2))
```

--

We can now compose our existing lenses:

```scala
val classifierName = composeLL(
  classifierLens,
  nameLens
)
```

---

## Composing lenses ²

And this works as expected:

```scala
classifierName.set("news_20")(service)
// res2: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))

classifierName.modify(_.toUpperCase)(service)
// res3: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(NEWS20,20))
```

---

## Conclusions

* Lenses are used to drill down arbitrarily deep in nested product types
* Deep lenses are created by composing smaller ones together

---

class: center, middle

# Prisms & Optionals

---

## Motivation

We want to change the service's authentication user name.

--

We'll need a `Lens` on the `auth` field:

```scala
val authLens = Lens[MlService, Auth](
  (a, s) => s.copy(auth = a),
  s      => s.auth
)
```

---

## Motivation ²

We'll also need one on the `user` field of `Auth`:

```scala
val userLens = Lens[Auth, String](
  (a, s) => ???,
  s      => ???
)
```

--

Can we write the _getter_ part?

---

## `Lens.get` for a sum type

```scala
val getter: Get[Auth, String] = {
  case Auth.Login(s, _) => s
  case Auth.Token(t)    => ???
}
```

We can't. Not all `Auth` values have a user.

--

What we need is a way to go from `Auth` to `Auth.Login`.

A way to separate `Auth` into its constituent types...

---

## Prism!

```scala
trait Prism[S, A] {
  def get(s: S): Option[A]
}
```

--

We'll also need to turn a value back into the original type.

---

## Prism ²


```scala
trait Prism[S, A] {
  def get(s: S): Option[A]
  def set(a: A): S
}
```

--

Given `get` and `set`, we should be able to implement `modify`.

---

## Prism ³

```scala
trait Prism[S, A] {
  def get(s: S): Option[A]
  def set(a: A): S

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

--

Lastly, we're going to need simple ways of creating `Prism` values.

---

## Creation helper


```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: PartialFunction[S, A]
  ): Prism[S, A] = new Prism[S, A] {
    val lifted = getter.lift

    override def set(a: A) = setter(a)
    override def get(s: S) = lifted(s)
  }
}
```

--

We've been down this road before. We know we'll want to compose.

---

## Composing `Prism`s

```scala
def composePP[S, A, B](
  p1: Prism[S, A],
  p2: Prism[A, B]
) = new Prism[S, B] {

  override def set(b: B) = ???
  override def get(s: S) = ???
}
```

---

## Composing `Prism`s ²

```scala
def composePP[S, A, B](
  p1: Prism[S, A],
  p2: Prism[A, B]
) = new Prism[S, B] {

  override def set(b: B) = p1.set(p2.set(b))
  override def get(s: S) = ???
}
```

---

## Composing `Prism`s ³

```scala
def composePP[S, A, B](
  p1: Prism[S, A],
  p2: Prism[A, B]
) = new Prism[S, B] {

  override def set(b: B) = p1.set(p2.set(b))
  override def get(s: S) = p1.get(s).flatMap(p2.get)
}
```

---

## Using prisms

We can now write the prism we needed:

```scala
val loginPrism = Prism[Auth, Auth.Login](
  a => a,
  { case s: Auth.Login => s }
)
```

---

## Using prisms ²

We'll also need to go from an `Auth.Login` to its name:

```scala
val userNameLens = Lens[Auth.Login, String](
  (a, s) => s.copy(user = a),
  s      => s.user
)
```

--

But... how do we compose a `loginPrism` and `userNameLens`?

---

## `Prism` + `Lens` = `Prism`?

Can the composition be implemented as a `Prism`?

--

```scala
def composePL[S, A, B](
  p: Prism[S, A],
  l: Lens[A, B]
) = new Prism[S, B] {

  override def set(b: B) = {
    val a: A = ???
    p.set(l.set(b)(a))
  }
  override def get(s: S) = ???
}
```

It cannot: there's no way to get an `A` in `set`.

---

## `Prism` + `Lens` = `Lens`?

Can the composition be implemented as a `Lens`?

--

```scala
def composePL[S, A, B](
  p: Prism[S, A],
  l: Lens[A, B]
) = new Lens[S, B] {

  override def set(b: B)(s: S) = ???
  override def get(s: S)       = p.get(s).map(l.get)
}
// <console>:20: error: type mismatch;
//  found   : Option[B]
//  required: B
//          override def get(s: S)       = p.get(s).map(l.get)
//                                                     ^
```

It cannot: `get` cannot be implemented (sanely).

---

## `Prism` + `Lens` = `???`

It looks like we'll need a third structure - a hybrid between a `Lens` and a `Prism`.

A `Lens` for something that might not be there...


---

## Optional!

```scala
trait Optional[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

--

(Yeah, the fancy optics metaphor apparently breaks down at this point)

--

We'll need the usual creation helpers.

---

## Creation helper

```scala
object Optional {
  def apply[S, A](
    setter: (A, S) => S,
    getter: S      => Option[A]
  ): Optional[S, A] = new Optional[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

---

## Compositions galore

The following few slides show the code for all remaining `Lens` / `Prism` / `Optional` compositions.

They're here for the sake of completeness and can safely be skipped.

---

## `Prism` with `Lens`

```scala
def composePL[S, A, B](
  p: Prism[S, A],
  l: Lens[A, B]
) = new Optional[S, B] {

  override def set(b: B)(s: S) = p.modify(l.set(b))(s)
  override def get(s: S)       = p.get(s).map(l.get)
}
```


---

## `Lens` with `Prism`


```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = new Optional[S, B] {

  override def set(b: B)(s: S) = l.set(p.set(b))(s)
  override def get(s: S)       = p.get(l.get(s))
}
```

---

## `Optional` with `Optional`


```scala
def composeOO[S, A, B](
  o1: Optional[S, A],
  o2: Optional[A, B]
) = new Optional[S, B] {

  override def set(b: B)(s: S) = o1.modify(o2.set(b))(s)
  override def get(s: S)       = o1.get(s).flatMap(o2.get)
}
```

---

## `Optional` with `Prism`


```scala
def composeOP[S, A, B](
  o: Optional[S, A],
  p: Prism[A, B]
) = new Optional[S, B] {

  override def set(b: B)(s: S) = o.set(p.set(b))(s)
  override def get(s: S)       = o.get(s).flatMap(p.get)
}
```

---

## `Prism` with `Optional`


```scala
def composePO[S, A, B](
  p: Prism[S, A],
  o: Optional[A, B]
) = new Optional[S, B] {

  override def set(b: B)(s: S) = p.modify(o.set(b))(s)
  override def get(s: S)       = p.get(s).flatMap(o.get)
}
```

---

## `Optional` with `Lens`


```scala
def composeOL[S, A, B](
  o: Optional[S, A],
  l: Lens[A, B]
) = new Optional[S, B] {

  override def set(b: B)(s: S) = o.modify(l.set(b))(s)
  override def get(s: S)       = o.get(s).map(l.get)
}
```

---

## `Lens` with `Optional`


```scala
def composeLO[S, A, B](
  l: Lens[S, A],
  o: Optional[A, B]
) = new Optional[S, B] {

  override def set(b: B)(s: S) = l.modify(o.set(b))(s)
  override def get(s: S)       = o.get(l.get(s))
}
```

---

## Compositions galore ²

Done. You can start paying attention again.

---

## Using prisms

Here's our complete prism:

```scala
val userName = composeOL(
  composeLP(authLens, loginPrism),
  userNameLens
)
```

---

## Using prisms ²

And this, finally, works as expected:

```scala
userName.set("psmith")(service)
// res4: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

---

## Conclusions

* Prisms are used to chose a specific value constructor in a sum type
* Optionals represent "paths" that might not exist
* Lenses, prisms and optionals all compose

---

class: center, middle

# Libraries

---

## Scalaz

[scalaz] has lenses:

```scala
import scalaz.Lens.lensu

val classifierLens = lensu[MlService, Classifier](
  (s, a) => s.copy(classifier = a),
  _.classifier
)

val nameLens = lensu[Classifier, String](
  (s, a) => s.copy(name = a),
  _.name
)

val classifierName = classifierLens andThen nameLens
```

---

## Scalaz ²

The use-site API is similar to ours:

```scala
classifierName.set(service, "news_20")
// res5: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))
```

---

## Shapeless

[shapeless] has lenses and prisms (but sort of conflates prisms and optionals):

```scala
import shapeless.lens

val classifierName = lens[MlService].classifier.name

val userName = lens[MlService].auth.user
```
---

## Shapeless ²

The use-site API is almost the same as ours:

```scala
classifierName.set(service)("news_20")
// res6: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))

userName.set(service)("psmith")
// res7: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

---

## Monocle

[Monocle] is the reference Scala optics implementation:

```scala
import monocle.macros._

val classifierName = GenLens[MlService](_.classifier).
  composeLens(GenLens[Classifier](_.name))

val userName = GenLens[MlService](_.auth).
  composePrism(GenPrism[Auth, Auth.Login]).
  composeLens(GenLens[Auth.Login](_.user))
```

---

## Monocle ²

The use-site API is the same as ours:

```scala
classifierName.set("news_20")(service)
// res8: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))

userName.set("psmith")(service)
// res9: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

---

## Monocle ³

[Monocle] offers far more tools than lenses, prisms and optionals.

They rely on concepts that are out of scope for this presentation, though.

---

## Conclusions

* Optics are popular enough to warrant at least 3 different popular implementations
* Should you need optics, your best choice is probably [Monocle]

---

class: center, middle

# Concrete use case: ConfigPath

---

## Configuration ADT

We're working with nested configuration data:

```scala
sealed trait Config

object Config {
  case class Section(children: Map[String, Config]) extends Config
  case class Field(value: String) extends Config
}
```

---

## MlService configuration

For example:

```json
{
  "auth": {
    "token": "0xCAFEBABE"
  },
  "classifier": {
    "name"      : "news20"
    "classCount": 20
  }
}
```

---

## MlService configuration ²

For example:

```scala
val conf = Config.Section(Map(
  "auth" -> Config.Section(Map(
    "token" -> Config.Field("0xCAFEBABE")
  )),
  "classifier" -> Config.Section(Map(
    "name"       -> Config.Field("news20"),
    "classCount" -> Config.Field("20")
  ))
))
```

--

We'd like to provide a comfortable way to query / update it.

Optics are one possible good solution.

---

## Obvious optics

We'll need a prism on `Section`:

```scala
val section = Prism[Config, Config.Section](
  a => a,
  { case a: Config.Section => a }
)
```

---

## Obvious optics ²

And one on `Field`:

```scala
val field = Prism[Config, Config.Field](
  a => a,
  { case a: Config.Field => a }
)
```

---

## Fancier optics

We'll also need to access a given field of a section:

```scala
def sectionChild(name: String) = Optional[Config.Section, Config](
  (a, s) => Config.Section(s.children + (name -> a)),
  _.children.get(name)
)
```
---

## First attempt

```scala
case class ConfigPath(current: Optional[Config, Config]) {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def child(name: String) = ConfigPath(
    composeOO(
      composeOP(current, section),
      sectionChild(name)
    )
  )
}
```

--

This looks about right, but... how do we create a `ConfigPath` value?

We need a way to reference the root of the configuration.

---

## Boring optics

```scala
val identityOpt = Optional[Config, Config](
  (_, a) => a,
  Option.apply
)
```

--

Our root element is now:

```scala
ConfigPath(identityOpt)
```


---

## Tying these together

```scala
val classifierName =
  ConfigPath(identityOpt).
    child("classifier").
    child("name").
    asField
```

--

This works, but it's not exactly comfortable.

---

## Aside: `Dynamic`

We'll be using a slightly obscure Scala feature: [`Dynamic`](https://www.scala-lang.org/api/current/scala/Dynamic.html).

```scala
import scala.language.dynamics

object UpCase extends Dynamic {
  def selectDynamic(s: String): String = s.toUpperCase
}
```

--

Referencing unknown members is equivalent to applying `selectDynamic`:

```scala
UpCase.bar
// res11: String = BAR
```

---

## Dynamic `ConfigPath`

Rewriting `ConfigPath` with `Dynamic`:


```scala
case class ConfigPath(
    current: Optional[Config, Config]
  ) extends Dynamic {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def selectDynamic(child: String) = ConfigPath(
    composeOO(
      composeOP(current, section),
      sectionChild(child)
    )
  )
}
```

---

## Almost there

```scala
val classifierName =
  ConfigPath(identityOpt).
    classifier.
    name.
    asField
```

--

Much better, but this `ConfigPath(identityOpt)` is unpleasant.

---

## Final steps

```scala
val root = ConfigPath(identityOpt)
```

--

We can now write:

```scala
val classifierName = root.classifier.name.asField
```

--

This behaves as expected:

```scala
classifierName.set(Config.Field("news_20"))(conf)
// res12: Config = Section(Map(auth -> Section(Map(token -> Field(0xCAFEBABE))), classifier -> Section(Map(name -> Field(news20), classCount -> Field(20)))))
```

---

## Conclusions

* Optics can be used for more than just exploring ADTs
* [circe] has a realy nice example with [`JsonPath`]

---

class: center, middle

# Wrapping things up

---

## Conclusions

* Optics are a great tool for working with nested data
* You do not need to understand the underlying theory to use them
* Existing libraries such as [shapeless] and [Monocle] make creating them (almost) painless

---

## More information

Slides available on https://nrinaudo.github.io/optics-from-the-ground-up/

Find me on Twitter ([@NicolasRinaudo])

Get in touch with [Besedo], we're always on the lookout for Scala talent

Slides backed by [remark.js] and the amazing [tut]

---

class: center, middle

# Thanks!

[scalaz]:https://scalaz.github.io/7/
[shapeless]:https://github.com/milessabin/shapeless
[Monocle]:https://github.com/julien-truffaut/Monocle
[remark.js]:https://remarkjs.com
[tut]:https://github.com/tpolecat/tut
[Besedo]:https://twitter.com/besedo_official
[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[circe]:https://circe.github.io/circe/
[`JsonPath`]:https://circe.github.io/circe/optics.html

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
        highlightStyle: 'solarized-dark'
      });
    </script>
  </body>
</html>
