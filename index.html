<!DOCTYPE html>
<html>
  <head>
    <title>Optics from the ground up</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Optics from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Algebraic Data Types

???

Before we can tackle optics, we need a quick reminder of what ADTs are.

---

## Product types

```scala
case class Classifier(
  name      : String,
  classCount: Int
)
```

---

## Product types

```scala
case `class Classifier`(
  name      : String,
  classCount: Int
)
```
---

## Product types

```scala
case class Classifier(
  `name      : String`,
  classCount: Int
)
```

---

## Product types

```scala
case class Classifier(
  name      : String,
  `classCount: Int`
)
```


???

Product types can be thought of as an `AND` operator: `Classifier` is a `String AND Int`.
---

## Product types

.center[![Classifier](img/classifier.svg)]

---

## Product types

.center[![Classifier](img/classifier-1.svg)]

---

## Product types

.center[![Classifier](img/classifier-2.svg)]

---

## Product types

.center[![Classifier](img/classifier-3.svg)]

---

## Product types

.center[![Classifier](img/classifier.svg)]

---

## Sum types

```scala
sealed trait Auth

case class Token(
  token: String
) extends Auth

case class Login(
  user    : String,
  password: String
) extends Auth
```

---

## Sum types

```scala
sealed `trait Auth`

case class Token(
  token: String
) extends Auth

case class Login(
  user    : String,
  password: String
) extends Auth
```

---

## Sum types

```scala
sealed trait Auth

case `class Token`(
  token: String
) `extends Auth`

case class Login(
  user    : String,
  password: String
) extends Auth
```

---

## Sum types

```scala
sealed trait Auth

case class Token(
  token: String
) extends Auth

case `class Login`(
  user    : String,
  password: String
) `extends Auth`
```

???

Sum types can be thought of as an `OR` operator: `Auth` is a `Token OR Login`.

---

## Sum types

.center[![Auth](img/auth.svg)]

---

## Sum types

.center[![Auth](img/auth-1.svg)]

---

## Sum types

.center[![Auth](img/auth-2.svg)]

---

## Sum types

.center[![Auth](img/auth-3.svg)]

---

## Sum types

.center[![Auth](img/auth.svg)]

---

## ADTs

```scala
case class MlService(
  auth      : Auth,
  classifier: Classifier
)
```

---

## ADTs

```scala
case `class MlService`(
  auth      : Auth,
  classifier: Classifier
)
```

---

## ADTs

```scala
case class MlService(
  `auth      : Auth`,
  classifier: Classifier
)
```

---

## ADTs

```scala
case class MlService(
  auth      : Auth,
  `classifier: Classifier`
)
```

???

We often mean "composition of sum and product types" when we say ADTs.

---

## ADTs

.center[![MlService](img/mlservice-1.svg)]

---

## ADTs

.center[![MlService](img/mlservice-2.svg)]

---

## ADTs

.center[![MlService](img/mlservice-3.svg)]

---

## ADTs

.center[![MlService](img/mlservice-4.svg)]

---

## ADTs

.center[![MlService](img/mlservice.svg)]

---

## Key takeaways

* Product types aggregate types with an `⋀`
* Sum types aggregate types with an `⋁`
* ADTs are nested sum and product types

---

class: center, middle

# Lenses

---

## Motivation

```scala
val service = MlService(
  Login("jsmith", "Tr0ub4dor&3"),
  Classifier("news20", 20)
)
```

---

## Motivation

```scala
val service = MlService(
  Login("jsmith", "Tr0ub4dor&3"),
  Classifier(`"news20"`, 20)
)
```

???
We want to change the classifier name to `NEWS20`.

---

## Motivation

.center[![Complete ADT](img/mlservice.svg)]

---

## Motivation

.center[![Service to classifier name](img/service-name.svg)]

---

## Motivation

.section[Java]

```scala
service.classifier.name = "NEWS20"
```

--

.section[Scala]

```scala
service.copy(
  classifier = service.classifier.copy(
    name = "NEWS20"
  )
)
```

???

FP likes to think it's more expressive, less boilerplatey than imperative. We need to get the upper hand back.

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
}
```

```scala
val nameSetter: Setter[MlService, String] = ???

val updated: MlService =
  nameSetter.set("NEWS20")(service)
```

---

## Generic setter type

```scala
trait Setter[`S`, A] {
  def set(a: A)(s: S): S
}
```

```scala
val nameSetter: Setter[`MlService`, String] = ???

val updated: MlService =
  nameSetter.set("NEWS20")(service)
```

---

## Generic setter type

```scala
trait Setter[S, `A`] {
  def set(a: A)(s: S): S
}
```

```scala
val nameSetter: Setter[MlService, `String`] = ???

val updated: MlService =
  nameSetter.set("NEWS20")(service)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  `def set(a: A)(s: S): S`
}
```

```scala
val nameSetter: Setter[MlService, String] = ???

val updated: MlService =
  nameSetter.`set("NEWS20")(service)`
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(`a: A`)(s: S): S
}
```

```scala
val nameSetter: Setter[MlService, String] = ???

val updated: MlService =
  nameSetter.set(`"NEWS20"`)(service)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(`s: S`): S
}
```

```scala
val nameSetter: Setter[MlService, String] = ???

val updated: MlService =
  nameSetter.set("NEWS20")(`service`)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): `S`
}
```

```scala
val nameSetter: Setter[MlService, String] = ???

val `updated: MlService` =
  nameSetter.set("NEWS20")(service)
```


???

But we want to upper case the whole thing, not set it to a known value...


---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def modify(f: A => A)(s: S): S
}
```

```scala
val updated: MlService =
  nameSetter.modify(_.toUpperCase)(service)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  `def modify(f: A => A)(s: S): S`
}
```

```scala
val updated: MlService =
  nameSetter.`modify(_.toUpperCase)(service)`
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def modify(`f: A => A`)(s: S): S
}
```

```scala
val updated: MlService =
  nameSetter.modify(`_.toUpperCase`)(service)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def modify(f: A => A)(`s: S`): S
}
```

```scala
val updated: MlService =
  nameSetter.modify(_.toUpperCase)(`service`)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def modify(f: A => A)(s: S): `S`
}
```

```scala
val `updated: MlService` =
  nameSetter.modify(_.toUpperCase)(service)
```

???

`modify` _could_ have a default implementation, if we had a `get`.

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

```scala
val classifierName: String =
  nameSetter.get(service)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  `def get(s: S): A`

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

```scala
val classifierName: String =
  nameSetter.`get(service)`
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def get(`s: S`): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

```scala
val classifierName: String =
  nameSetter.get(`service`)
```

---

## Generic setter type

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): `A`

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

```scala
val `classifierName: String` =
  nameSetter.get(service)
```


???

`Setter` doesn't seem like such a good name anymore though.

Our type allows us to _focus_ on a specific part of an ADT...

---

## Lens

```scala
trait Lens[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

---

## Lens

```scala
trait `Lens[S, A]` {
  def set(a: A)(s: S): S
  def get(s: S): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

???

This looks painful to instantiate. Let's give ourselves helpers.

---

## Lens

```scala
object Lens {
  def apply[S, A](
    setter: (A, S) => S,
    getter: S      => A
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

---

## Lens

```scala
object `Lens` {
  def apply[S, A](
    setter: (A, S) => S,
    getter: S      => A
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

---

## Lens

```scala
object Lens {
  `def apply[S, A]`(
    setter: (A, S) => S,
    getter: S      => A
  ) = `new Lens[S, A]` {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

---

## Lens

```scala
object Lens {
  def apply[S, A](
    `setter: (A, S) => S`,
    getter: S      => A
  ) = new Lens[S, A] {

    override `def set(a: A)(s: S) = setter(a, s)`
    override def get(s: S)       = getter(s)
  }
}
```

---

## Lens

```scala
object Lens {
  def apply[S, A](
    setter: (A, S) => S,
    `getter: S      => A`
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override `def get(s: S)       = getter(s)`
  }
}
```

???

Let's create a couple of type aliases to help with some intuition I want you to have later...

---

## Lens

```scala
type Set[S, A] = (A, S) => S

type Get[S, A] = S => A
```

---

## Lens

```scala
type `Set[S, A]` = `(A, S) => S`

type Get[S, A] = S => A
```

---

## Lens

```scala
type Set[S, A] = (A, S) => S

type `Get[S, A]` = `S => A`
```

---

## Lens

```scala
object Lens {
  def apply[S, A](
    setter: Set[S, A],
    getter: Get[S, A]
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

---

## Lens

```scala
object Lens {
  def apply[S, A](
    `setter: Set[S, A]`,
    `getter: Get[S, A]`
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

???

Now that we have all the tools we need, let's see what we're trying to achieve

---

## Service → Classifier name

.center[![Service to classifier name](img/service-name.svg)]

???

This suggests that, rather than go directly from the first to the last element in the path, we should probably create segments and link them up somehow.

---

## Service → Classifier


.center[![Service to classifier](img/service-classifier.svg)]

---

## Service → Classifier

```scala
val serviceClassifier = Lens[MlService, Classifier](
  setter = (a, s) => s.copy(classifier = a),
  getter = s      => s.classifier
)
```

---

## Service → Classifier

```scala
val serviceClassifier = `Lens[MlService, Classifier]`(
  setter = (a, s) => s.copy(classifier = a),
  getter = s      => s.classifier
)
```

---

## Service → Classifier

```scala
val serviceClassifier = Lens[MlService, Classifier](
  setter = `(a, s) => s.copy(classifier = a)`,
  getter = s      => s.classifier
)
```

---

## Service → Classifier

```scala
val serviceClassifier = Lens[MlService, Classifier](
  setter = (a, s) => s.copy(classifier = a),
  getter = `s      => s.classifier`
)
```

---

## Classifier → name

.center[![Classifier to name](img/classifier-name.svg)]

---

## Classifier → name

```scala
val classifierName = Lens[Classifier, String](
  setter = (a, s) => s.copy(name = a),
  getter = s      => s.name
)
```

---

## Classifier → name

```scala
serviceClassifier.modify(classifierName.set("NEWS20"))(service)
// res1: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(NEWS20,20))
```

???

This is better than what we started with, but not by much...

It often helps to turn such things into functions to identify more generic patterns.

---

## Composing lenses

```scala
def setName(name: String, service: MlService) =
  serviceClassifier.modify(classifierName.set(name))(service)
```

---

## Composing lenses

```scala
def setName(`name: String`, service: MlService) =
  serviceClassifier.modify(classifierName.set(`name`))(service)
```

---

## Composing lenses

```scala
def setName(name: String, `service: MlService`) =
  serviceClassifier.modify(classifierName.set(name))(`service`)
```

---

## Composing lenses

```scala
def setName(
    serviceClassifier: Lens[MlService, Classifier],
    nameClassifier: Lens[Classifier, String]
  )
  (name: String, service: MlService): MlService =
    serviceClassifier.modify(nameClassifier.set(name))(service)
```

---

## Composing lenses

```scala
def setName(
    `serviceClassifier: Lens[MlService, Classifier]`,
    nameClassifier: Lens[Classifier, String]
  )
  (name: String, service: MlService): MlService =
    `serviceClassifier`.modify(nameClassifier.set(name))(service)
```

---

## Composing lenses

```scala
def setName(
    serviceClassifier: Lens[MlService, Classifier],
    `nameClassifier: Lens[Classifier, String]`
  )
  (name: String, service: MlService): MlService =
    serviceClassifier.modify(`nameClassifier`.set(name))(service)
```

---

## Composing lenses

```scala
def setName(
    serviceClassifier: Lens[MlService, `Classifier`],
    nameClassifier: Lens[`Classifier`, String]
  )
  (name: String, service: MlService): MlService =
    serviceClassifier.modify(nameClassifier.set(name))(service)
```

???

There is nothing in this implementation that relies on knowing the types `MlService`, `Classifier`, or `String`.

---

## Composing lenses

```scala
def setter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  (b: B, s: S): S =
    l1.modify(l2.set(b))(s)
```

---

## Composing lenses

```scala
def setter[S, A, B](
    l1: Lens[S, `A`],
    l2: Lens[`A`, B]
  )
  (b: B, s: S): S =
    l1.modify(l2.set(b))(s)
```

---

## Composing lenses

```scala
def setter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  `(b: B, s: S): S` =
    l1.modify(l2.set(b))(s)
```

???

This is starting to look familiar...

---

## Composing lenses

```scala
def setter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Set[S, B] = (b, s) =>
    l1.modify(l2.set(b))(s)
```

---

## Composing lenses

```scala
def setter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : `Set[S, B]` = (b, s) =>
    l1.modify(l2.set(b))(s)
```

???

That looks a lot like half a `Lens[S, B]`. Can we write the other half?

---

## Composing lenses

```scala
def getter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Get[S, B] = s =>
    l2.get(l1.get(s))
```

---

## Composing lenses

```scala
def getter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : `Get[S, B]` = s =>
    l2.get(l1.get(s))
```

---

## Composing lenses

```scala
def getter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Get[S, B] = s =>
    l2.get(`l1.get(s)`)
```

---

## Composing lenses

```scala
def getter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Get[S, B] = s =>
    `l2.get`(l1.get(s))
```

???

We can compose lenses!

---

## Composing lenses

```scala
def composeLL[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  ) = Lens[S, B](
    setter(l1, l2),
    getter(l1, l2)
  )
```

---

## Composing lenses

```scala
def composeLL[S, A, B](
    l1: `Lens[S, A]`,
    l2: `Lens[A, B]`
  ) = Lens[S, B](
    setter(l1, l2),
    getter(l1, l2)
  )
```

---

## Composing lenses

```scala
def composeLL[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  ) = `Lens[S, B]`(
    setter(l1, l2),
    getter(l1, l2)
  )
```


???

Now that we can compose lenses, let's recall what we're trying to achieve

---

## Service → Classifier → name

.center[![Service to classifier name](img/service-name.svg)]

---

## Service → Classifier → name

```scala
val serviceClassifierName = composeLL(
  serviceClassifier,
  classifierName
)
```

???

And this works out as expected

--

```scala
serviceClassifierName.set("NEWS20")(service)
// res2: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(NEWS20,20))

serviceClassifierName.modify(_.toUpperCase)(service)
// res3: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(NEWS20,20))
```

---

## Key takeaway


Lenses are used to drill down arbitrarily deep in nested product types

---

class: center, middle

# Prisms & Optionals

---

## Motivation

```scala
val service = MlService(
  Login("jsmith", "Tr0ub4dor&3"),
  Classifier("news20", 20)
)
```

---

## Motivation

```scala
val service = MlService(
  Login(`"jsmith"`, "Tr0ub4dor&3"),
  Classifier("news20", 20)
)
```

???

We want to change the service's authentication user name.

---

## Motivation

.center[![Complete ADT](img/mlservice.svg)]

---

## Motivation

.center[![Service to user](img/service-user.svg)]

???

First, we need to go to the auth...

---

## Service → Auth

.center[![Service to auth](img/service-auth.svg)]

---

## Service → Auth


```scala
val serviceAuth = Lens[MlService, Auth](
  setter = (a, s) => s.copy(auth = a),
  getter = s      => s.auth
)
```

???

Then, for the next link...

---

## Auth → Login

.center[![Auth to login](img/auth-login.svg)]

???

This looks dodgy - the arrow is different, we're working with sum types...

One option is to sort of ignore the problem and see how far we can get...

---

## Auth → user?

.center[![Auth to user](img/auth-user.svg)]

---

## Auth → user?

```scala
val authUser = Lens[Auth, String](
  setter = (a, s) => ???,

  // Auth -> String
  getter = s => s match {
    case Login(user, _) => user
    case Token(token)   => ???
  }
)
```
---


## Auth → user?

```scala
val authUser = `Lens[Auth, String]`(
  setter = (a, s) => ???,

  // Auth -> String
  getter = s => s match {
    case Login(user, _) => user
    case Token(token)   => ???
  }
)
```



---

## Auth → user?

```scala
val authUser = Lens[Auth, String](
  setter = (a, s) => ???,

* // Auth -> String
* getter = s => s match {
*   case Login(user, _) => user
*   case Token(token)   => ???
* }
)
```

---

## Auth → user?

```scala
val authUser = Lens[Auth, String](
  setter = (a, s) => ???,

  // Auth -> String
  getter = s => s match {
    `case Login(user, _) => user`
    case Token(token)   => ???
  }
)
```

---

## Auth → user?

```scala
val authUser = Lens[Auth, String](
  setter = (a, s) => ???,

  // Auth -> String
  getter = s => s match {
    case Login(user, _) => user
    `case Token(token)   => ???`
  }
)
```

???
We're stuck. `Token` doesn't have a user name to return.

---

## Auth → Login

.center[![Auth to login](img/auth-login.svg)]

???
What we need is a way to go from `Auth` to `Login`.

A way to separate `Auth` into its constituent types...

---

## Prism

```scala
trait Prism[S, A] {
  def set(a: A): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, Login] = ???

val updated: Auth = authLogin.set(Login("foo", "bar"))

val login: Option[Login] = authLogin.get(service.auth)
```

---

## Prism

```scala
trait Prism[`S`, A] {
  def set(a: A): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[`Auth`, Login] = ???

val updated: Auth = authLogin.set(Login("foo", "bar"))

val login: Option[Login] = authLogin.get(service.auth)
```

---

## Prism

```scala
trait Prism[S, `A`] {
  def set(a: A): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, `Login`] = ???

val updated: Auth = authLogin.set(Login("foo", "bar"))

val login: Option[Login] = authLogin.get(service.auth)
```

---

## Prism

```scala
trait Prism[S, A] {
  def set(a: A): S
  `def get(s: S): Option[A]`

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, Login] = ???

val updated: Auth = authLogin.set(Login("foo", "bar"))

val `login: Option[Login] = authLogin.get(service.auth)`
```

---

## Prism

```scala
trait Prism[S, A] {
  def set(a: A): S
  def get(`s: S`): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, Login] = ???

val updated: Auth = authLogin.set(Login("foo", "bar"))

val login: Option[Login] = authLogin.get(`service.auth`)
```

---

## Prism

```scala
trait Prism[S, A] {
  def set(a: A): S
  def get(s: S): `Option[A]`

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, Login] = ???

val updated: Auth = authLogin.set(Login("foo", "bar"))

val `login: Option[Login]` = authLogin.get(service.auth)
```

---

## Prism

```scala
trait Prism[S, A] {
  `def set(a: A): S`
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, Login] = ???

val `updated: Auth = authLogin.set(Login("foo", "bar"))`

val login: Option[Login] = authLogin.get(service.auth)
```

---

## Prism

```scala
trait Prism[S, A] {
  def set(`a: A`): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, Login] = ???

val updated: Auth = authLogin.set(`Login("foo", "bar")`)

val login: Option[Login] = authLogin.get(service.auth)
```

---

## Prism

```scala
trait Prism[S, A] {
  def set(a: A): `S`
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

```scala
val authLogin: Prism[Auth, Login] = ???

val `updated: Auth` = authLogin.set(Login("foo", "bar"))

val login: Option[Login] = authLogin.get(service.auth)
```

???

We're going to need simple ways of creating `Prism` values.

---

## Prism


```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: S => Option[A]
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }
}
```

---

## Prism


```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    `getter: S => Option[A]`
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }
}
```

???

We can make this more user friendly by supporting partial functions.

---

## Prism

```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: S => Option[A]
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }

  def fromPartial[S, A](
    setter: A => S,
    getter: PartialFunction[S, A]
  ) = Prism(setter, getter.lift)
}
```

---

## Prism

```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: S => Option[A]
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }

* def fromPartial[S, A](
*   setter: A => S,
*   getter: PartialFunction[S, A]
* ) = Prism(setter, getter.lift)
}
```

---

## Prism

```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: S => Option[A]
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }

  def fromPartial[S, A](
    setter: A => S,
    `getter: PartialFunction[S, A]`
  ) = Prism(setter, getter.lift)
}
```

---

## Prism

```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: S => Option[A]
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }

  def fromPartial[S, A](
    setter: A => S,
    getter: PartialFunction[S, A]
  ) = Prism(setter, `getter.lift`)
}
```

???

We can now create our missing link

---

## Auth → Login

.center[![Auth to login](img/auth-login.svg)]

---

## Auth → Login

```scala
val authLogin = Prism.fromPartial[Auth, Login](
  setter = a => a,
  getter = { case s: Login => s }
)
```

---

## Auth → Login

```scala
val authLogin = `Prism`.fromPartial`[Auth, Login]`(
  setter = a => a,
  getter = { case s: Login => s }
)
```

---

## Auth → Login

```scala
val authLogin = Prism.fromPartial[Auth, Login](
  setter = `a => a`,
  getter = { case s: Login => s }
)
```

---

## Auth → Login

```scala
val authLogin = Prism.fromPartial[Auth, Login](
  setter = a => a,
  getter = `{ case s: Login => s }`
)
```

???

And... compose them?

---

## Service → Login

.center[![Service to login](img/service-login.svg)]

???

Can we make this work with what we've built so far?

---

## Lens ∘ Prism ≟ Prism

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Prism[S, B](

  // B => S
  setter = b => {
    val s: S = ???
    l.set(p.set(b))(s)
  },

  getter = s => ???
)
```

---

## Lens ∘ Prism ≟ Prism

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Prism[S, B](

* // B => S
* setter = b => {
*   val s: S = ???
*   l.set(p.set(b))(s)
* },

  getter = s => ???
)
```

---

## Lens ∘ Prism ≟ Prism

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Prism[S, B](

  // `B` => S
  setter = `b` => {
    val s: S = ???
    l.set(p.set(b))(s)
  },

  getter = s => ???
)
```

---

## Lens ∘ Prism ≟ Prism

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Prism[S, B](

  // B => `S`
  setter = b => {
    val `s: S = ???`
    l.set(p.set(b))(s)
  },

  getter = s => ???
)
```

???

We can't. We can go from a `B` to an `A`, but not from an `A` to an `S`.

---

## Lens ∘ Prism ≟ Lens

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Lens[S, B](

  setter = (b, s) => ???,

  // S => B
  getter = s => {
    val ob: Option[B] = p.get(l.get(s))
    val b: B = ???
    b
  }
)
```

---

## Lens ∘ Prism ≟ Lens

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Lens[S, B](

  setter = (b, s) => ???,

* // S => B
* getter = s => {
*   val ob: Option[B] = p.get(l.get(s))
*   val b: B = ???
*   b
* }
)
```

---

## Lens ∘ Prism ≟ Lens

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Lens[S, B](

  setter = (b, s) => ???,

  // `S` => B
  getter = `s` => {
    val ob: Option[B] = p.get(l.get(s))
    val b: B = ???
    b
  }
)
```

---

## Lens ∘ Prism ≟ Lens

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Lens[S, B](

  setter = (b, s) => ???,

  // S => `B`
  getter = s => {
    val ob: Option[B] = p.get(l.get(s))
    val `b: B = ???`
    b
  }
)
```

???

It cannot: `get` cannot be implemented (sanely).

It looks like we'll need a third structure - a hybrid between a `Lens` and a `Prism`.

A `Lens` for something that might not be there...

---

## Optional

```scala
trait Optional[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val updated: Service =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)

val login: Option[Login] = serviceLogin.get(service)
```

---

## Optional

```scala
trait Optional[`S`, A] {
  def set(a: A)(s: S): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[`Service`, Login] = ???

val updated: Service =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)

val login: Option[Login] = serviceLogin.get(service)
```

---

## Optional

```scala
trait Optional[S, `A`] {
  def set(a: A)(s: S): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, `Login`] = ???

val updated: Service =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)

val login: Option[Login] = serviceLogin.get(service)
```

---

## Optional

```scala
trait Optional[S, A] {
  `def set(a: A)(s: S): S`
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val `updated: Service` =
  `serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)`

val login: Option[Login] = serviceLogin.get(service)
```

---

## Optional

```scala
trait Optional[S, A] {
  def set(`a: A`)(s: S): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val updated: Service =
  serviceLogin.set(`Login("psmith", "Tr0ub4dor&3")`)(service)

val login: Option[Login] = serviceLogin.get(service)
```

---

## Optional

```scala
trait Optional[S, A] {
  def set(a: A)(`s: S`): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val updated: Service =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(`service`)

val login: Option[Login] = serviceLogin.get(service)
```

---

## Optional

```scala
trait Optional[S, A] {
  def set(a: A)(s: S): `S`
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val `updated: Service` =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)

val login: Option[Login] = serviceLogin.get(service)
```

---

## Optional

```scala
trait Optional[S, A] {
  def set(a: A)(s: S): S
  `def get(s: S): Option[A]`

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val updated: Service =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)

val `login: Option[Login] = serviceLogin.get(service)`
```

---

## Optional

```scala
trait Optional[S, A] {
  def set(a: A)(s: S): S
  def get(`s: S`): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val updated: Service =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)

val login: Option[Login] = serviceLogin.get(`service`)
```

---

## Optional

```scala
trait Optional[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): Option[`A`]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

```scala
val serviceLogin: Optional[Service, Login] = ???

val updated: Service =
  serviceLogin.set(Login("psmith", "Tr0ub4dor&3"))(service)

val `login: Option[Login]` = serviceLogin.get(service)
```


???

(Yeah, the fancy optics metaphor apparently breaks down at this point)


We'll need the usual creation helpers.

---

## Optional

```scala
object Optional {
  def apply[S, A](
    setter: (A, S) => S,
    getter: S      => Option[A]
  ) = new Optional[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

---

class: center, middle

# Intermission: composition galore

---


## Prism ∘ Prism

```scala
def composePP[S, A, B](
  p1: Prism[S, A],
  p2: Prism[A, B]
) = Prism[S, B](
  setter = b => p1.set(p2.set(b)),
  getter = s => p1.get(s).flatMap(p2.get)
)
```

---

## Prism ∘ Lens

```scala
def composePL[S, A, B](
  p: Prism[S, A],
  l: Lens[A, B]
) = Optional[S, B](
  setter = (b, s) => p.modify(l.set(b))(s),
  getter = s      => p.get(s).map(l.get)
)
```

---

## Lens ∘ Prism

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Optional[S, B](
  setter = (b, s) => l.set(p.set(b))(s),
  getter = s      => p.get(l.get(s))
)
```

---

## Optional ∘ Optional

```scala
def composeOO[S, A, B](
  o1: Optional[S, A],
  o2: Optional[A, B]
) = Optional[S, B](
  setter = (b, s) => o1.modify(o2.set(b))(s),
  getter = s      => o1.get(s).flatMap(o2.get)
)
```

---

## Optional ∘ Prism


```scala
def composeOP[S, A, B](
  o: Optional[S, A],
  p: Prism[A, B]
) = Optional[S, B](
  setter = (b, s) => o.set(p.set(b))(s),
  getter = s      => o.get(s).flatMap(p.get)
)
```

---

## Prism ∘ Optional


```scala
def composePO[S, A, B](
  p: Prism[S, A],
  o: Optional[A, B]
) = Optional[S, B](
  setter = (b, s) => p.modify(o.set(b))(s),
  getter = s      => p.get(s).flatMap(o.get)
)
```

---

## Optional ∘ Lens


```scala
def composeOL[S, A, B](
  o: Optional[S, A],
  l: Lens[A, B]
) = Optional[S, B](
  setter = (b, s) => o.modify(l.set(b))(s),
  getter = s      => o.get(s).map(l.get)
)
```

---

## Lens ∘ Optional


```scala
def composeLO[S, A, B](
  l: Lens[S, A],
  o: Optional[A, B]
) = Optional[S, B](
  setter = (b, s) => l.modify(o.set(b))(s),
  getter = s      => o.get(l.get(s))
)
```

---

class: center, middle

# End of intermission

???

We can now compose our way down to he leaf of our tree...

---

## Service → Login

.center[![Service to login](img/service-login.svg)]

---

## Service → Login

```scala
val serviceLogin = composeLP(
  serviceAuth,
  authLogin
)
```
---

## Login → user

.center[![Login to user](img/login-user.svg)]

---

## Login → user

```scala
val loginUser = Lens[Login, String](
  setter = (a, s) => s.copy(user = a),
  getter = s      => s.user
)
```

---

## Service → user

.center[![Service to user](img/service-user.svg)]

---

## Service → user

```scala
val serviceUser = composeOL(
  serviceLogin,
  loginUser
)
```

--

```scala
serviceUser.set("psmith")(service)
// res4: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

???

And *that* is far shorter than the Java alternative. Take that, Java! Only took 70-odd slides of boilerplate to be able to write cool one liners.

---

## Key takeaways


* Prisms are used to explore sum types
* They compose with lenses and yield optionals

---

class: center, middle

# Libraries

---

## Scalaz


```scala
import scalaz.Lens.lensu

val classifierLens = lensu[MlService, Classifier](
  (s, a) => s.copy(classifier = a),
  s      => s.classifier
)

val nameLens = lensu[Classifier, String](
  (s, a) => s.copy(name = a),
  s      => s.name
)

val classifierName = classifierLens andThen nameLens
```

???
[scalaz] has lenses, but no prisms or optionals

---

## Scalaz

```scala
classifierName.set(service, "news_20")
// res5: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))
```

---

## Shapeless

```scala
import shapeless.lens

val classifierName = lens[MlService].classifier.name

val userName = lens[MlService].auth.user
```

???

[shapeless] has lenses and prisms (but sort of conflates prisms and optionals):

---

## Shapeless

```scala
classifierName.set(service)("news_20")
// res6: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))

userName.set(service)("psmith")
// res7: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

---

## Monocle

```scala
import monocle.macros._

val classifierName = GenLens[MlService](_.classifier.name)

val userName = GenLens[MlService](_.auth).
  composePrism(GenPrism[Auth, Login]).
  composeLens(GenLens[Login](_.user))
```

???

[Monocle] is the reference Scala optics implementation:


---

## Monocle

```scala
classifierName.set("news_20")(service)
// res8: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))

userName.set("psmith")(service)
// res9: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

???

[Monocle] offers far more tools than lenses, prisms and optionals.

They rely on concepts that are out of scope for this presentation, though.

---

## Key takeaway

Optics are useful enough to warrant implementations in at least 3 major libraries

---

class: center, middle

# Concrete use case: ConfigPath

???

We can use optics to work with something other than ADTs

---

## Configuration ADT

```scala
sealed trait Config

case class Section(
  children: Map[String, Config]
) extends Config

case class Field(
  value: String
) extends Config
```

---

## Configuration ADT

```scala
*sealed trait Config

case class Section(
  children: Map[String, Config]
) extends Config

case class Field(
  value: String
) extends Config
```

---

## Configuration ADT

```scala
sealed trait Config

*case class Section(
* children: Map[String, Config]
*) extends Config

case class Field(
  value: String
) extends Config
```

---

## Configuration ADT

```scala
sealed trait Config

case class Section(
  `children: Map[String, Config]`
) extends Config

case class Field(
  value: String
) extends Config
```

---

## Configuration ADT

```scala
sealed trait Config

case class Section(
  children: Map[String, Config]
) extends Config

*case class Field(
* value: String
*) extends Config
```

---

## Configuration ADT

```scala
sealed trait Config

case class Section(
  children: Map[String, Config]
) extends Config

case class Field(
  `value: String`
) extends Config
```

???

This could be used to store configuration expressed in a JSON-like format

---

## Configuration ADT


```json
{
  "auth": {
    "token": "0xCAFEBABE"
  },
  "classifier": {
    "name"      : "news20",
    "classCount": 20
  }
}
```

---

## Configuration ADT

```scala
val conf = Section(Map(
  "auth" -> Section(Map(
    "token" -> Field("0xCAFEBABE")
  )),
  "classifier" -> Section(Map(
    "name"       -> Field("news20"),
    "classCount" -> Field("20")
  ))
))
```

???

We'd like to provide a comfortable way to query / update it.

Optics are one possible good solution.

---

## Configuration optics

```scala
val section = Prism.fromPartial[Config, Section](
  setter = a => a,
  getter = { case a: Section => a }
)

val field = Prism.fromPartial[Config, Field](
  setter = a => a,
  getter = { case a: Field => a }
)
```

---

## Configuration optics

```scala
val section = `Prism`.fromPartial`[Config, Section]`(
  setter = a => a,
  getter = { case a: Section => a }
)

val field = Prism.fromPartial[Config, Field](
  setter = a => a,
  getter = { case a: Field => a }
)
```

---

## Configuration optics

```scala
val section = Prism.fromPartial[Config, Section](
  setter = a => a,
  getter = { case a: Section => a }
)

val field = `Prism`.fromPartial`[Config, Field]`(
  setter = a => a,
  getter = { case a: Field => a }
)
```

---

## Configuration optics

```scala
def sectionChild(name: String) = Optional[Section, Config](
  setter = (a, s) => Section(s.children + (name -> a)),
  getter = s      => s.children.get(name)
)
```

---

## Configuration optics

```scala
def sectionChild(name: String) = `Optional[Section, Config]`(
  setter = (a, s) => Section(s.children + (name -> a)),
  getter = s      => s.children.get(name)
)
```

---

## Configuration optics

```scala
def sectionChild(name: String) = Optional[Section, Config](
  setter = `(a, s) => Section(s.children + (name -> a))`,
  getter = s      => s.children.get(name)
)
```
---

## Configuration optics

```scala
def sectionChild(name: String) = Optional[Section, Config](
  setter = (a, s) => Section(s.children + (name -> a))`
  getter = `s      => s.children.get(name)`
)
```

---

## ConfigPath

```scala
case class ConfigPath(current: Optional[Config, Config]) {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def child(name: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(name)
    )
  )
}
```

---

## ConfigPath

```scala
case class ConfigPath(`current: Optional[Config, Config]`) {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def child(name: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(name)
    )
  )
}
```

---

## ConfigPath

```scala
case class ConfigPath(current: Optional[Config, Config]) {

  `val asField   = composeOP(current, field)`
  val asSection = composeOP(current, section)

  def child(name: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(name)
    )
  )
}
```

---

## ConfigPath

```scala
case class ConfigPath(current: Optional[Config, Config]) {

  val asField   = composeOP(current, field)
  `val asSection = composeOP(current, section)`

  def child(name: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(name)
    )
  )
}
```

---

## ConfigPath

```scala
case class ConfigPath(current: Optional[Config, Config]) {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

* def child(name: String) = ConfigPath(
*   composeOO(
*     asSection,
*     sectionChild(name)
*   )
* )
}
```

???

`ConfigPath` can be thought of as a cursor on a position in the configuration.

But how do we refer to the root of our tree?


---

## ConfigPath

```scala
val identityOpt = Optional[Config, Config](
  setter = (a, _) => a,
  getter = s      => Some(s)
)
```

---

## ConfigPath

```scala
val identityOpt = `Optional[Config, Config]`(
  setter = (a, _) => a,
  getter = s      => Some(s)
)
```

---

## ConfigPath

```scala
val identityOpt = Optional[Config, Config](
  setter = `(a, _) => a`,
  getter = s      => Some(s)
)
```

---

## ConfigPath

```scala
val identityOpt = Optional[Config, Config](
  setter = (a, _) => a,
  getter = `s      => Some(s)`
)
```

---

## ConfigPath

```scala
val identityOpt = Optional[Config, Config](
  setter = (a, _) => a,
  getter = s      => Some(s)
)
```

```scala
ConfigPath(identityOpt)
```

???

We can now write an entire path

---

## ConfigPath

```scala
val classifierName: Optional[Config, Field] =
  ConfigPath(identityOpt).
    child("classifier").
    child("name").
    asField
```

---

## ConfigPath

```scala
val classifierName: `Optional[Config, Field]` =
  ConfigPath(identityOpt).
    child("classifier").
    child("name").
    asField
```

---

## ConfigPath

```scala
val classifierName: Optional[Config, Field] =
  `ConfigPath(identityOpt)`.
    child("classifier").
    child("name").
    asField
```

---

## ConfigPath

```scala
val classifierName: Optional[Config, Field] =
  ConfigPath(identityOpt).
    `child("classifier")`.
    child("name").
    asField
```

---

## ConfigPath

```scala
val classifierName: Optional[Config, Field] =
  ConfigPath(identityOpt).
    child("classifier").
    `child("name")`.
    asField
```

---

## ConfigPath

```scala
val classifierName: Optional[Config, Field] =
  ConfigPath(identityOpt).
    child("classifier").
    child("name").
    `asField`
```


???

This works, but it's not exactly comfortable.

---

## Dynamic

```scala
import scala.language.dynamics

object UpCase extends Dynamic {
  def selectDynamic(missingMember: String): String =
    missingMember.toUpperCase
}
```

---

## Dynamic

```scala
import scala.language.dynamics

object UpCase extends `Dynamic` {
  def selectDynamic(missingMember: String): String =
    missingMember.toUpperCase
}
```

---

## Dynamic

```scala
import scala.language.dynamics

object UpCase extends Dynamic {
  def selectDynamic(`missingMember: String`): String =
    missingMember.toUpperCase
}
```

---

## Dynamic

```scala
import scala.language.dynamics

object UpCase extends Dynamic {
  `def selectDynamic(missingMember: String): String` =
    missingMember.toUpperCase
}
```

---

## Dynamic

```scala
import scala.language.dynamics

object UpCase extends Dynamic {
  def selectDynamic(missingMember: String): String =
    `missingMember.toUpperCase`
}
```

---

## Dynamic

```scala
import scala.language.dynamics

object UpCase extends Dynamic {
  def selectDynamic(missingMember: String): String =
    missingMember.toUpperCase
}
```

```scala
UpCase.bar
// res11: String = BAR
```

???
Referencing unknown members is equivalent to applying `selectDynamic`:

---

## Dynamic ConfigPath

```scala
case class ConfigPath(
    current: Optional[Config, Config]
  ) extends Dynamic {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def selectDynamic(child: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(child)
    )
  )
}
```

---

## Dynamic ConfigPath

```scala
case class ConfigPath(
    current: Optional[Config, Config]
  ) `extends Dynamic` {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def selectDynamic(child: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(child)
    )
  )
}
```

---

## Dynamic ConfigPath

```scala
case class ConfigPath(
    current: Optional[Config, Config]
  ) extends Dynamic {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  `def selectDynamic(child: String)` = ConfigPath(
    composeOO(
      asSection,
      sectionChild(child)
    )
  )
}
```

---

## Dynamic ConfigPath

```scala
val classifierName =
  ConfigPath(identityOpt).
    classifier.
    name.
    asField
```

---

## Dynamic ConfigPath

```scala
val classifierName =
  `ConfigPath(identityOpt)`.
    classifier.
    name.
    asField
```

???

Much better, but this `ConfigPath(identityOpt)` is unpleasant.

---

## Dynamic ConfigPath

```scala
val root = ConfigPath(identityOpt)
```

--
```scala
val classifierName = root.classifier.name.asField
```

--
```scala
classifierName.set(Field("NEWS20"))(conf)
// res12: Config = Section(Map(auth -> Section(Map(token -> Field(0xCAFEBABE))), classifier -> Section(Map(name -> Field(NEWS20), classCount -> Field(20)))))
```

---
## Key takeaway

Optics can be used for more than just exploring "simple" ADTs

---
class: center, middle

# Wrapping things up

---

## If you only remember 1 slide...

* Lenses are used to drill down arbitrarily deep in nested product types
* Prisms are used to explore sum types
* They compose into optionals
* You do not need to understand the theory (but it's beautiful)

---
class: center, middle

# Questions?

[scalaz]:https://scalaz.github.io/7/
[shapeless]:https://github.com/milessabin/shapeless
[Monocle]:https://github.com/julien-truffaut/Monocle
[Besedo]:https://twitter.com/besedo_official
[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo

    </textarea>
    <script src="js/remark.js" type="text/javascript"></script>
    <script type="text/javascript">
        var slideshow = remark.create({
        highlightStyle: 'github',
        highlightSpans: true,
        highlightLines: true
      });
    </script>
  </body>
</html>
