<!DOCTYPE html>
<html>
  <head>
    <title>Optics from the ground up</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
      <textarea id="source">
class: center, middle

# Optics from the ground up

Nicolas Rinaudo • [@NicolasRinaudo] • [Besedo]

---

class: center, middle

# Algebraic Data Types

???

Before we can tackle optics, we need a quick reminder of what ADTs are.

---

## Product types

```scala
case class Classifier(
  name      : String,
  classCount: Int
)
```
???

Product types can be thought of as an `AND` operator: `Classifier` is a `String AND Int`.
---

## Product types .super[2]

.center[![Classifier graph](img/classifier.svg)]

---

## Sum types

```scala
sealed trait Auth

object Auth {
  case class Token(token: String) extends Auth

  case class Login(
    user    : String,
    password: String
  ) extends Auth
}
```

???

Sum types can be thought of as an `OR` operator: `Auth` is a `Token OR Login`.

---

## Sum types .super[2]

.center[![Auth graph](img/auth.svg)]

---

## ADTs

```scala
case class MlService(
  auth      : Auth,
  classifier: Classifier
)
```

???

We often mean "composition of sum and product types" when we say ADTs.

---

## ADTs .super[2]

.center[![MlService graph](img/mlservice.svg)]

---

class: center, middle

# Lenses

---

## Motivation

```scala
val service = MlService(
  Auth.Login("jsmith", "Tr0ub4dor&3"),
  Classifier("news20", 20)
)
```

???
We want to change the classifier name to `NEWS20`.

---

## Motivation .super[2]

.center[![Classifier Name lens](img/service-name.svg)]

---

## Motivation .super[3]

.section[Java]

```scala
service.classifier.name = "NEWS20"
```

--

.section[Scala]

```scala
service.copy(
  classifier = service.classifier.copy(
    name = "NEWS20"
  )
)
```

???

FP likes to think it's more expressive, less boilerplatey than imperative. We need to get the upper hand back.

---

## Generic setter type


```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
}
```

???

Or, expressed with the types we're looking for...

--

```scala
val nameSetter: Setter[MlService, String] = ???

nameSetter.set("NEWS20")(service)
```

???

But we want to upper case the whole thing, not set it to a known value...


---

## Set and modify

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def modify(f: A => A)(s: S): S
}
```

--

```scala
nameSetter.modify(_.toUpperCase)(service)
```

???

`modify` _could_ have a default implementation, if we had a `get`.

---

## Set and get

```scala
trait Setter[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

???

`Setter` doesn't seem like such a good name anymore though.

Our type allows us to _focus_ on a specific part of an ADT...

---

## Lens!

```scala
trait Lens[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): A

  def modify(f: A => A)(s: S): S = set(f(get(s)))(s)
}
```

???

This looks painful to instantiate. Let's give ourselves helpers.

---

## Creation helper

```scala
object Lens {
  def apply[S, A](
    setter: (A, S) => S,
    getter: S      => A
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

???

Let's create a couple of type aliases to help with some intuition I want you to have later...

---
## Creation helper .super[2]

```scala
type Set[S, A] = (A, S) => S

type Get[S, A] = S => A
```

---
## Creation helper .super[3]

```scala
object Lens {
  def apply[S, A](
    setter: Set[S, A],
    getter: Get[S, A]
  ) = new Lens[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

???

Now that we have all the tools we need, let's see what we're trying to achieve

---

## Modifying the classifier name

.center[![Classifier Name lens](img/service-name.svg)]

???

This suggests that, rather than go directly from the first to the last element in the path, we should probably create segments and link them up somehow.

---

## Service to classifier


.center[![Classifier lens](img/service-classifier.svg)]

---

## Service to classifier .super[2]

```scala
val serviceClassifier = Lens[MlService, Classifier](
  (a, s) => s.copy(classifier = a),
  s      => s.classifier
)
```

---

## Classifier to name

.center[![Classifier Name lens](img/classifier-name.svg)]

---

## Classifier to name .super[2]

```scala
val classifierName = Lens[Classifier, String](
  (a, s) => s.copy(name = a),
  s      => s.name
)
```

---

## Using lenses

```scala
serviceClassifier.modify(classifierName.set("NEWS20"))(service)
// res1: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(NEWS20,20))
```

???

This is better than what we started with, but not by much...

It often helps to turn such things into functions to identify more generic patterns.

---

## Tidying up

```scala
def setName(
    l1: Lens[MlService, Classifier],
    l2: Lens[Classifier, String]
  )
  (b: String, s: MlService): MlService =
    l1.modify(l2.set(b))(s)
```

???

There is nothing in this implementation that relies on knowing the types `MlService`, `Classifier`, or `String`.

---

## Polymorphic `setName`

```scala
def setName[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  (b: B, s: S): S =
    l1.modify(l2.set(b))(s)
```

???

This is starting to look familiar...

---

## Generic `setter`

```scala
def setter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Set[S, B] = (b, s) =>
    l1.modify(l2.set(b))(s)
```

???

That looks a lot like half a `Lens[S, B]`. Can we write the other half?

---

## Generic `getter`

```scala
def getter[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  )
  : Get[S, B] = s =>
    l2.get(l1.get(s))
```

???

We can compose lenses!

---
## Composing lenses

```scala
def composeLL[S, A, B](
    l1: Lens[S, A],
    l2: Lens[A, B]
  ) = Lens[S, B](setter(l1, l2), getter(l1, l2))
```

???

Now that we can compose lenses, let's recall what we're trying to achieve

---

## Service to name

.center[![Classifier Name lens](img/service-name.svg)]

---

## Service to name .super[2]

```scala
val serviceClassifierName = composeLL(
  serviceClassifier,
  classifierName
)
```

???

And this works out as expected

--

```scala
serviceClassifierName.set("NEWS20")(service)
// res2: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(NEWS20,20))

serviceClassifierName.modify(_.toUpperCase)(service)
// res3: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(NEWS20,20))
```

---

## Key takeaway


Lenses are used to drill down arbitrarily deep in nested product types

---

class: center, middle

# Prisms & Optionals

---

## Motivation

```scala
val service = MlService(
  Auth.Login("jsmith", "Tr0ub4dor&3"),
  Classifier("news20", 20)
)
```

???

We want to change the service's authentication user name.

---

## Motivation .super[2]

.center[![User name](img/service-user.svg)]

???

First, we need to go to the auth...

---

## Service to auth

.center[![User lens](img/service-auth.svg)]

---

## Service to auth .super[2]


```scala
val serviceAuth = Lens[MlService, Auth](
  (a, s) => s.copy(auth = a),
  s      => s.auth
)
```

???

Then, for the next link...

---

## Auth to login

.center[![Login prism](img/auth-login.svg)]

???

This looks dodgy - the arrow is different, we're working with sum types...

One option is to sort of ignore the problem and see how far we can get...

---

## Auth to user?

.center[![User lens](img/auth-user.svg)]

---

## Auth to user? .super[2]

```scala
val authUser = Lens[Auth, String](
  (a, s) => ???,

  // Auth -> String
  s => s match {
    case Auth.Login(user, _) => user
    case Auth.Token(token)   => ???
  }
)
```
???
We're stuck. `Auth.Token` doesn't have a user name to return.

---

## Auth to login

.center[![Login prism](img/auth-login.svg)]

???
What we need is a way to go from `Auth` to `Auth.Login`.

A way to separate `Auth` into its constituent types...

---

## Prism!

```scala
trait Prism[S, A] {
  def set(a: A): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))
    case None    => s
  }
}
```

???

We're going to need simple ways of creating `Prism` values.

---

## Creation helper


```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: S => Option[A]
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }
}
```

???

We can make this more user friendly by supporting partial functions.

---

## Creation helper .super[2]
```scala
object Prism {
  def apply[S, A](
    setter: A => S,
    getter: S => Option[A]
  ) = new Prism[S, A] {
    override def set(a: A) = setter(a)
    override def get(s: S) = getter(s)
  }

  def fromPartial[S, A](
    setter: A => S,
    getter: PartialFunction[S, A]
  ) = Prism(setter, getter.lift)
}
```

???

We can now create our missing link

---

## Auth to login

.center[![User lens](img/auth-login.svg)]

---

## Auth to login .super[2]

```scala
val authLogin = Prism.fromPartial[Auth, Auth.Login](
  a => a,
  { case s: Auth.Login => s }
)
```

???

And... compose them?

---

## Service to login

.center[![User lens](img/service-login.svg)]

???

Can we make this work with what we've built so far?

---

## `Lens` + `Prism` = `Prism`?

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Prism[S, B](

  // B => S
  b => {
    val s: S = ???
    l.set(p.set(b))(s)
  },

  s => ???
)
```

???

We can't. We can go from a `B` to an `A`, but not from an `A` to an `S`.

---

## `Lens` + `Prism` = `Lens`?

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Lens[S, B](

  (b, s) => ???,

  // S => B
  s      => p.get(l.get(s))
)
// <console>:23: error: type mismatch;
//  found   : Option[B]
//  required: B
//          s      => p.get(l.get(s))
//                         ^
```

???

It cannot: `get` cannot be implemented (sanely).

It looks like we'll need a third structure - a hybrid between a `Lens` and a `Prism`.

A `Lens` for something that might not be there...

---

## Optional!

```scala
trait Optional[S, A] {
  def set(a: A)(s: S): S
  def get(s: S): Option[A]

  def modify(f: A => A)(s: S): S = get(s) match {
    case Some(a) => set(f(a))(s)
    case None    => s
  }
}
```

???

(Yeah, the fancy optics metaphor apparently breaks down at this point)


We'll need the usual creation helpers.

---

## Creation helper

```scala
object Optional {
  def apply[S, A](
    setter: (A, S) => S,
    getter: S      => Option[A]
  ) = new Optional[S, A] {

    override def set(a: A)(s: S) = setter(a, s)
    override def get(s: S)       = getter(s)
  }
}
```

---

class: center, middle

# Intermission: composition galore

---


## `Prism` with `Prism`

```scala
def composePP[S, A, B](
  p1: Prism[S, A],
  p2: Prism[A, B]
) = Prism[S, B](
  b => p1.set(p2.set(b)),
  s => p1.get(s).flatMap(p2.get)
)
```

---

## `Prism` with `Lens`

```scala
def composePL[S, A, B](
  p: Prism[S, A],
  l: Lens[A, B]
) = Optional[S, B](
  (b, s) => p.modify(l.set(b))(s),
  s      => p.get(s).map(l.get)
)
```

---

## `Lens` with `Prism`

```scala
def composeLP[S, A, B](
  l: Lens[S, A],
  p: Prism[A, B]
) = Optional[S, B](
  (b, s) => l.set(p.set(b))(s),
  s      => p.get(l.get(s))
)
```

---

## `Optional` with `Optional`

```scala
def composeOO[S, A, B](
  o1: Optional[S, A],
  o2: Optional[A, B]
) = Optional[S, B](
  (b, s) => o1.modify(o2.set(b))(s),
  s      => o1.get(s).flatMap(o2.get)
)
```

---

## `Optional` with `Prism`


```scala
def composeOP[S, A, B](
  o: Optional[S, A],
  p: Prism[A, B]
) = Optional[S, B](
  (b, s) => o.set(p.set(b))(s),
  s      => o.get(s).flatMap(p.get)
)
```

---

## `Prism` with `Optional`


```scala
def composePO[S, A, B](
  p: Prism[S, A],
  o: Optional[A, B]
) = Optional[S, B](
  (b, s) => p.modify(o.set(b))(s),
  s      => p.get(s).flatMap(o.get)
)
```

---

## `Optional` with `Lens`


```scala
def composeOL[S, A, B](
  o: Optional[S, A],
  l: Lens[A, B]
) = Optional[S, B](
  (b, s) => o.modify(l.set(b))(s),
  s      => o.get(s).map(l.get)
)
```

---

## `Lens` with `Optional`


```scala
def composeLO[S, A, B](
  l: Lens[S, A],
  o: Optional[A, B]
) = Optional[S, B](
  (b, s) => l.modify(o.set(b))(s),
  s      => o.get(l.get(s))
)
```

---

class: center, middle

# End of intermission

???

We can now compose our way down to he leaf of our tree...

---

## Service to login

.center[![User lens](img/service-login.svg)]

---

## Service to login .super[2]

```scala
val serviceLogin = composeLP(serviceAuth, authLogin)
```
---

## Login to user

.center[![User lens](img/login-user.svg)]

---

## Login to user .super[2]

```scala
val loginUser = Lens[Auth.Login, String](
  (a, s) => s.copy(user = a),
  s      => s.user
)
```

---

## Service to user

.center[![User name](img/service-user.svg)]

---

## Service to user .super[2]

```scala
val serviceUser = composeOL(
  serviceLogin,
  loginUser
)
```

--

```scala
serviceUser.set("psmith")(service)
// res4: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

???

And *that* is far shorter than the Java alternative. Take that, Java! Only took 70-odd slides of boilerplate to be able to write cool one liners.

---

## Key takeaways


* Prisms are used to explore sum types
* They compose with lenses and yield optionals

---

class: center, middle

# Libraries

---

## Scalaz


```scala
import scalaz.Lens.lensu

val classifierLens = lensu[MlService, Classifier](
  (s, a) => s.copy(classifier = a),
  s      => s.classifier
)

val nameLens = lensu[Classifier, String](
  (s, a) => s.copy(name = a),
  s      => s.name
)

val classifierName = classifierLens andThen nameLens
```

???
[scalaz] has lenses, but no prisms or optionals

---

## Scalaz .super[2]

```scala
classifierName.set(service, "news_20")
// res5: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))
```

---

## Shapeless

```scala
import shapeless.lens

val classifierName = lens[MlService].classifier.name

val userName = lens[MlService].auth.user
```

???

[shapeless] has lenses and prisms (but sort of conflates prisms and optionals):

---

## Shapeless .super[2]

```scala
classifierName.set(service)("news_20")
// res6: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))

userName.set(service)("psmith")
// res7: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

---

## Monocle

```scala
import monocle.macros._

val classifierName = GenLens[MlService](_.classifier.name)

val userName = GenLens[MlService](_.auth).
  composePrism(GenPrism[Auth, Auth.Login]).
  composeLens(GenLens[Auth.Login](_.user))
```

???

[Monocle] is the reference Scala optics implementation:


---

## Monocle .super[2]

```scala
classifierName.set("news_20")(service)
// res8: MlService = MlService(Login(jsmith,Tr0ub4dor&3),Classifier(news_20,20))

userName.set("psmith")(service)
// res9: MlService = MlService(Login(psmith,Tr0ub4dor&3),Classifier(news20,20))
```

???

[Monocle] offers far more tools than lenses, prisms and optionals.

They rely on concepts that are out of scope for this presentation, though.

---

## Key takeaway

Optics are useful enough to warrant implementations in at least 3 major libraries

---

class: center, middle

# Concrete use case: ConfigPath

???

We can use optics to work with something other than ADTs

---

## Configuration ADT

```scala
sealed trait Config

object Config {
  case class Section(children: Map[String, Config]) extends Config
  case class Field(value: String) extends Config
}
```

???

This could be used to store configuration expressed in a JSON-like format

---

## MlService configuration


```json
{
  "auth": {
    "token": "0xCAFEBABE"
  },
  "classifier": {
    "name"      : "news20",
    "classCount": 20
  }
}
```

---

## MlService configuration .super[2]

```scala
val conf = Config.Section(Map(
  "auth" -> Config.Section(Map(
    "token" -> Config.Field("0xCAFEBABE")
  )),
  "classifier" -> Config.Section(Map(
    "name"       -> Config.Field("news20"),
    "classCount" -> Config.Field("20")
  ))
))
```

???

We'd like to provide a comfortable way to query / update it.

Optics are one possible good solution.

---

## Obvious optics

```scala
val section = Prism.fromPartial[Config, Config.Section](
  a => a,
  { case a: Config.Section => a }
)

val field = Prism.fromPartial[Config, Config.Field](
  a => a,
  { case a: Config.Field => a }
)
```

---

## Fancier optics

```scala
def sectionChild(name: String) = Optional[Config.Section, Config](
  (a, s) => Config.Section(s.children + (name -> a)),
  _.children.get(name)
)
```

---

## First attempt

```scala
case class ConfigPath(current: Optional[Config, Config]) {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def child(name: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(name)
    )
  )
}
```

???

`ConfigPath` can be thought of as a cursor on a position in the configuration.

But how do we refer to the root of our tree?


---

## Boilerplate

```scala
val identityOpt = Optional[Config, Config](
  (a, _) => a,
  Option.apply
)
```

--

```scala
ConfigPath(identityOpt)
```

???

We can now write an entire path

---

## Tying these together

```scala
val classifierName =
  ConfigPath(identityOpt).
    child("classifier").
    child("name").
    asField
```

???

This works, but it's not exactly comfortable.

---

## Aside: [`Dynamic`]

```scala
import scala.language.dynamics

object UpCase extends Dynamic {
  def selectDynamic(s: String): String = s.toUpperCase
}
```

???
Referencing unknown members is equivalent to applying `selectDynamic`:

--
```scala
UpCase.bar
// res11: String = BAR
```

---
## Dynamic `ConfigPath`

```scala
case class ConfigPath(
    current: Optional[Config, Config]
  ) extends Dynamic {

  val asField   = composeOP(current, field)
  val asSection = composeOP(current, section)

  def selectDynamic(child: String) = ConfigPath(
    composeOO(
      asSection,
      sectionChild(child)
    )
  )
}
```

---

## Almost there

```scala
val classifierName =
  ConfigPath(identityOpt).
    classifier.
    name.
    asField
```

???

Much better, but this `ConfigPath(identityOpt)` is unpleasant.

---

## Final steps

```scala
val root = ConfigPath(identityOpt)
```

--
```scala
val classifierName = root.classifier.name.asField
```

--
```scala
classifierName.set(Config.Field("news_20"))(conf)
// res12: Config = Section(Map(auth -> Section(Map(token -> Field(0xCAFEBABE))), classifier -> Section(Map(name -> Field(news_20), classCount -> Field(20)))))
```

---
## Key takeaway

Optics can be used for more than just exploring "simple" ADTs

---
class: center, middle

# Wrapping things up

---

## If you only remember 1 slide...

* Lenses are used to drill down arbitrarily deep in nested product types
* Prisms are used to explore sum types
* They compose into optionals
* You do not need to understand the theory (but it's beautiful)

---
class: center, middle

# Questions?

[scalaz]:https://scalaz.github.io/7/
[shapeless]:https://github.com/milessabin/shapeless
[Monocle]:https://github.com/julien-truffaut/Monocle
[Besedo]:https://twitter.com/besedo_official
[@NicolasRinaudo]:https://twitter.com/NicolasRinaudo
[`Dynamic`]:https://www.scala-lang.org/api/current/scala/Dynamic.html

    </textarea>
    <script src="js/remark.js" type="text/javascript"></script>
    <script type="text/javascript">
        var slideshow = remark.create({
        highlightStyle: 'github'
      });
    </script>
  </body>
</html>
